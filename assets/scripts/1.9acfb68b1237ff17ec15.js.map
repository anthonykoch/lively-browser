{"version":3,"sources":["webpack:///./node_modules/core-js/library/fn/symbol/index.js","webpack:///./node_modules/scuffka-javascript/dist/instrument.js","webpack:///./node_modules/core-js/library/modules/es7.symbol.async-iterator.js","webpack:///./node_modules/core-js/library/modules/es7.symbol.observable.js","webpack:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack:///./node_modules/scuffka-javascript/dist/constants.js","webpack:///./node_modules/@babel/runtime/core-js/symbol.js"],"names":["__webpack_require__","module","exports","Symbol","_interopRequireDefault","__esModule","thorough","minimal","Insertion","isCallable","isLiteral","isUnaryVoid","isCall","isSymbol","isNaN","isUndefined","isIdentifier","isConsoleLog","_symbol","_constants","IGNORE","default","isIgnored","node","hasOwnProperty","isInstrumentFunction","type","callee","name","VAR_INSPECT","isInstrumented","isInstrumentIdentifier","ignore","_len","arguments","length","nodes","Array","_key","i","expr","object","property","operator","_ref","id","context","this","_ref2","t","types","ast","insertions","addInsertionPoint","isExpression","push","trackStatement","insertionId","identifier","number","numericLiteral","call","callExpression","statement","expressionStatement","track","forceSequence","sequenceExpression","traverse","ReturnStatement","path","argument","insertBefore","BreakStatement","ContinueStatement","ForStatement","test","update","ForOfStatement","right","DoWhileStatement","WhileStatement","IfStatement","SwitchStatement","discriminant","SwitchCase","LogicalExpression","left","ExpressionStatement","expression","VariableDeclaration","parent","declarations","declaration","init","_ref3","lastLoc","loc","propertyInterpIdentifier","VAR_MEMBER_PROPERTY_INTERP","objectInterpIdentifier","VAR_MEMBER_OBJECT_INTERP","objectAssignment","assignmentExpression","objectAssignmentProperty","memberExpression","computed","propertyAssignment","interpCall","memberIdentifier","member","memberCall","concat","unary","unaryExpression","string","stringLiteral","bin","binaryExpression","condition","conditionalExpression","seq","parenthesizedExpression","VAR_INTERP","assignment","createInspectCall","prefix","_seq","trackProp","prop","trackRight","trackLeft","trackTest","trackSelf","replaceWith","trackArgument","trackTestVisitor","trackSelfVisitor","Identifier","isReferencedIdentifier","Literal","ConditionalExpression","consequent","alternate","NewExpression","CallExpression","MemberExpression","ObjectProperty","key","BinaryExpression","ClassExpression","UnaryExpression","UpdateExpression","ThisExpression","FunctionExpression","ArrowFunctionExpression","ObjectExpression","AwaitExpression","AssignmentExpression","ArrayExpression","elements","obj"],"mappings":"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","file":"assets/scripts/1.9acfb68b1237ff17ec15.js","sourcesContent":["require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/symbol/index.js\n// module id = BwfY\n// module chunks = 0 1","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.thorough = exports.minimal = exports.Insertion = exports.isCallable = exports.isLiteral = exports.isUnaryVoid = exports.isCall = exports.isSymbol = exports.isNaN = exports.isUndefined = exports.isIdentifier = exports.isConsoleLog = void 0;\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime/core-js/symbol\"));\n\nvar _constants = require(\"./constants\");\n\nvar IGNORE = (0, _symbol.default)('IGNORE');\n\nvar isIgnored = function isIgnored(node) {\n  return node.hasOwnProperty(IGNORE);\n};\n\nvar isInstrumentFunction = function isInstrumentFunction(node) {\n  return node.type === 'CallExpression' && node.callee && node.callee.type === 'Identifier' && node.callee.name === _constants.VAR_INSPECT;\n};\n\nvar isInstrumentIdentifier = function isInstrumentIdentifier(node) {\n  return node.type === 'Identifier' && node.name === _constants.VAR_INSPECT;\n};\n\nvar isInstrumented = function isInstrumented(node) {\n  return isIgnored(node) || isInstrumentFunction(node) || isInstrumentIdentifier(node);\n};\n\nfunction ignore() {\n  for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n    nodes[_key] = arguments[_key];\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i][IGNORE] = true;\n  }\n\n  return nodes[0];\n}\n\nvar isConsoleLog = function isConsoleLog(expr) {\n  return expr.type === 'CallExpression' && expr.callee && expr.callee.type === 'MemberExpression' && expr.callee.object && expr.callee.object.name === 'console' && expr.callee.property && expr.callee.property.name === 'log';\n};\n\nexports.isConsoleLog = isConsoleLog;\n\nvar isIdentifier = function isIdentifier(expr, name) {\n  return expr.type === 'Identifier' && expr.name === name;\n};\n\nexports.isIdentifier = isIdentifier;\n\nvar isUndefined = function isUndefined(expr) {\n  return isIdentifier(expr, 'undefined');\n};\n\nexports.isUndefined = isUndefined;\n\nvar isNaN = function isNaN(expr) {\n  return isIdentifier(expr, 'NaN');\n};\n\nexports.isNaN = isNaN;\n\nvar isSymbol = function isSymbol(node) {\n  return node.type === 'CallExpression' && node.callee && node.callee.name === 'Symbol';\n};\n\nexports.isSymbol = isSymbol;\n\nvar isCall = function isCall(node) {\n  return node.type === 'CallExpression';\n};\n\nexports.isCall = isCall;\n\nvar isUnaryVoid = function isUnaryVoid(node) {\n  return node.type === 'UnaryExpression' && node.operator === 'void';\n};\n\nexports.isUnaryVoid = isUnaryVoid;\n\nvar isLiteral = function isLiteral(node) {\n  var type = node.type;\n  return type === 'NullLiteral' || type === 'StringLiteral' || type === 'ObjectExpression' || type === 'ObjectLiteral' || type === 'ArrayExpression' || type === 'ArrayLiteral' || type === 'BooleanLiteral' || type === 'NumericLiteral' || type === 'Literal' || type === 'TemplateLiteral' || type === 'RegExpLiteral' || isUndefined(node) || isNaN(node) || isSymbol(node);\n};\n/**\n * Returns true if the node is a callable expression.\n */\n\n\nexports.isLiteral = isLiteral;\n\nvar isCallable = function isCallable(_ref) {\n  var type = _ref.type;\n  return type === 'ClassExpression' || type === 'FunctionExpression' || type === 'ArrowFunctionExpression';\n};\n\nexports.isCallable = isCallable;\n\nvar Insertion = function Insertion(id, node, context) {\n  this.id = id;\n  this.node = node;\n  this.context = context;\n  this.type = node.type;\n};\n/**\n * Transforms an AST to track a minimal amount of expressions. This transform\n * attempts to insert as few insertions as possible for better performance.\n *\n * @param options.types - babel types\n * @param options.ast - An ast to traverse\n * @param options.traverse - The babel traverser function\n */\n\n\nexports.Insertion = Insertion;\n\nvar minimal = function minimal(_ref2) {\n  var t = _ref2.types,\n      ast = _ref2.ast,\n      traverse = _ref2.traverse;\n  var insertions = [];\n  var id = -1;\n\n  var addInsertionPoint = function addInsertionPoint(node, isExpression, context) {\n    if (isExpression === void 0) {\n      isExpression = false;\n    }\n\n    id += 1;\n    insertions.push({\n      type: node.type,\n      context: context,\n      isExpression: isExpression,\n      node: node,\n      id: id\n    });\n    return id;\n  };\n\n  var trackStatement = function trackStatement(node, context) {\n    var insertionId = addInsertionPoint(node, false, context);\n    var identifier = t.identifier(_constants.VAR_INSPECT);\n    var number = t.numericLiteral(insertionId);\n    var call = t.callExpression(identifier, [number]);\n    var statement = t.expressionStatement(call);\n    ignore(statement, call, identifier, number, call);\n    return statement;\n  };\n\n  var track = function track(node, forceSequence, context) {\n    if (forceSequence === void 0) {\n      forceSequence = false;\n    }\n\n    var insertionId = addInsertionPoint(node, true, context); // console.log('is', node.type, isLiteral(node) || isCallable(node))\n\n    if (node.type === 'CallExpression' && node.callee.type === 'Identifier') {\n      // Fixes an issue where a call expression that has an undeclared identifier\n      // creates a stack trace with incorrect line/column\n      var number = t.numericLiteral(0);\n      var identifier = t.identifier(node.callee.name);\n      node.callee = t.sequenceExpression([number, identifier]);\n      ignore(node.callee, number, identifier);\n    }\n\n    if (forceSequence || isCallable(node)) {\n      // Don't track these since it's redundant information\n      return t.sequenceExpression([t.callExpression(t.identifier(_constants.VAR_INSPECT), [t.numericLiteral(insertionId)]), node]);\n    } else {\n      return t.callExpression(t.identifier(_constants.VAR_INSPECT), [t.numericLiteral(id), node]);\n    }\n  };\n\n  var visitors = {\n    // ConditionalExpression(path: Path) {\n    // TODO:\n    // trackSelf(path);\n    // },\n    ReturnStatement: function ReturnStatement(path) {\n      if (path.node.argument != null) {\n        path.node.argument = track(path.node.argument, false, 'ReturnStatement');\n      } else {\n        path.insertBefore(trackStatement(path.node, 'ReturnStatement'));\n      }\n    },\n    BreakStatement: function BreakStatement(path) {\n      path.insertBefore(trackStatement(path.node, 'BreakStatement'));\n    },\n    ContinueStatement: function ContinueStatement(path) {\n      path.insertBefore(trackStatement(path.node, 'ContinueStatement'));\n    },\n    ForStatement: function ForStatement(path) {\n      if (path.node.test != null) {\n        path.node.test = track(path.node.test, true, 'ForStatement.test');\n      }\n\n      if (path.node.update != null) {\n        path.node.update = track(path.node.update, true, 'ForStatement.update');\n      }\n    },\n    ForOfStatement: function ForOfStatement(path) {\n      path.node.right = track(path.node.right, false, 'ForOfStatement');\n    },\n    DoWhileStatement: function DoWhileStatement(path) {\n      path.node.test = track(path.node.test, false, 'DoWhileStatement');\n    },\n    WhileStatement: function WhileStatement(path) {\n      path.node.test = track(path.node.test, true, 'WhileStatement');\n    },\n    IfStatement: function IfStatement(path) {\n      path.node.test = track(path.node.test, true, 'IfStatement');\n    },\n    SwitchStatement: function SwitchStatement(path) {\n      path.node.discriminant = track(path.node.discriminant, false, 'SwitchStatement');\n    },\n    SwitchCase: function SwitchCase(path) {\n      if (path.node.test != null) {\n        path.node.test = track(path.node.test, false, 'SwitchCase');\n      }\n    },\n    LogicalExpression: function LogicalExpression(path) {\n      path.node.left = track(path.node.left, true, 'LogicalExpression');\n      path.node.right = track(path.node.right, true, 'LogicalExpression');\n    },\n    ExpressionStatement: function ExpressionStatement(path) {\n      var node = path.node;\n      var expr = node.expression;\n\n      if (isConsoleLog(expr) || isIgnored(node)) {\n        return;\n      }\n\n      ignore(node); // TODO: Maybe add a right side to insertions because `users = []` yields\n      //       `users = [] // []` in lively-browser or maybe just don't track\n      //       the expression?\n\n      node.expression = track(expr, false, 'ExpressionStatement');\n    },\n    VariableDeclaration: function VariableDeclaration(path) {\n      if (path.parent.type === 'ForStatement') {\n        return;\n      }\n\n      var node = path.node;\n      var length = node.declarations.length;\n\n      for (var i = 0; i < length; i++) {\n        var declaration = node.declarations[i];\n        var init = declaration.init;\n\n        if (init != null) {\n          declaration.init = track(init, false, 'VariableDeclaration');\n        }\n      }\n    }\n  };\n  traverse(ast, visitors);\n  return {\n    insertions: insertions\n  };\n};\n/**\n * Transforms an AST to track all expressions. This is terribly bad for performance\n * and should only be used for small scripts where performance is not necessary.\n *\n * @param  {babel.types} options.types t\n * @param  {Object} options.ast\n * @param  {Function} options.traverse - The babel traverser function\n * @return {Object} Returns the insertions and bad loops\n */\n\n\nexports.minimal = minimal;\n\nvar thorough = function thorough(_ref3) {\n  var t = _ref3.types,\n      ast = _ref3.ast,\n      traverse = _ref3.traverse;\n  var insertions = [];\n  var id = -1;\n\n  var addInsertionPoint = function addInsertionPoint(node, context) {\n    id += 1;\n    insertions.push(new Insertion(id, node, context));\n    return id;\n  };\n\n  var lastLoc = null;\n  /**\n   * Wraps an expression in a notifier function and returns the\n   * notifier function\n   */\n\n  var track = function track(node, context) {\n    lastLoc = node && node.loc ? node.loc : lastLoc; // To make debugging easier\n    // if (node == null) {\n    // console.log(node, context)\n    // console.log(lastLoc)\n    // }\n    // console.log(node.type)\n\n    if (isInstrumented(node) || isIgnored(node)) {\n      return node;\n    }\n\n    var insertionId = addInsertionPoint(node, context);\n\n    if (node.type === 'CallExpression') {\n      if (node.callee.type === 'MemberExpression') {\n        // Fixes an issue where wrapping a member expression in a call function causes\n        // `this` to be means\n        var propertyInterpIdentifier = t.identifier(_constants.VAR_MEMBER_PROPERTY_INTERP);\n        var objectInterpIdentifier = t.identifier(_constants.VAR_MEMBER_OBJECT_INTERP); // THINKME: Is it really necessary to pass on the arguments if we know it's not going\n        //          to be a function?\n\n        var objectAssignment = t.assignmentExpression('=', objectInterpIdentifier, node.callee.object);\n        var objectAssignmentProperty = t.memberExpression(objectAssignment, node.callee.property, node.callee.computed);\n        var propertyAssignment = t.assignmentExpression('=', propertyInterpIdentifier, objectAssignmentProperty);\n        var interpCall = t.callExpression(propertyInterpIdentifier, []);\n        var memberIdentifier = t.identifier('call');\n        var member = t.memberExpression(propertyInterpIdentifier, memberIdentifier);\n        var memberCall = t.callExpression(member, [objectInterpIdentifier].concat(node.arguments));\n        var unary = t.unaryExpression('typeof', propertyInterpIdentifier);\n        var string = t.stringLiteral('function');\n        var bin = t.binaryExpression('===', unary, string);\n        var condition = t.conditionalExpression(bin, memberCall, interpCall);\n        var seq = t.sequenceExpression([propertyAssignment, condition]);\n        var paren = t.parenthesizedExpression(seq);\n        ignore(string, member, memberCall, memberIdentifier, bin, unary, condition, paren, objectAssignmentProperty, objectAssignment, objectInterpIdentifier, propertyAssignment, propertyInterpIdentifier);\n        node = seq;\n      } else {\n        node.callee = track(node.callee, 'CallExpression');\n      }\n    } else if (node.type === 'UpdateExpression') {\n      var identifier = t.identifier(_constants.VAR_INTERP);\n      var assignment = t.assignmentExpression('=', identifier, node);\n      var number = t.numericLiteral(1);\n      var call = createInspectCall(node.prefix ? ignore(t.binaryExpression(node.operator === '--' ? '+' : '-', identifier, number)) : identifier, insertionId);\n\n      var _seq = t.sequenceExpression([assignment, call]);\n\n      ignore(node, _seq, number, identifier, assignment);\n      return _seq;\n    }\n\n    return createInspectCall(node, insertionId);\n  };\n\n  var createInspectCall = function createInspectCall(node, insertionId) {\n    var name = t.identifier(_constants.VAR_INSPECT);\n    var number = t.numericLiteral(insertionId);\n    var call = t.callExpression(name, [number, node]);\n    return ignore(call, name, number);\n  };\n\n  var trackProp = function trackProp(prop) {\n    return function (path) {\n      return path.node[prop] = track(path.node[prop], path.node.type);\n    };\n  };\n\n  var trackRight = trackProp('right');\n  var trackLeft = trackProp('left');\n  var trackTest = trackProp('test');\n  /**\n   * Wraps an expression itself and checks the parent node that it\n   * has not already been instrumented.\n   */\n\n  var trackSelf = function trackSelf(path) {\n    if (!isInstrumented(path.parent)) {\n      path.replaceWith(track(path.node, path.parent.type));\n    }\n\n    return path.node;\n  };\n\n  var trackArgument = function trackArgument(path) {\n    if (path.node.argument != null && !isInstrumented(path.node.argument)) {\n      path.node.argument = track(path.node.argument, path.node.type);\n    }\n\n    return path.node.argument;\n  };\n\n  var trackRightVisitor = function trackRightVisitor(path) {\n    trackRight(path);\n  };\n\n  var trackTestVisitor = function trackTestVisitor(path) {\n    trackTest(path);\n  };\n\n  var trackSelfVisitor = function trackSelfVisitor(path) {\n    trackSelf(path);\n  };\n\n  var visitors = {\n    Identifier: function Identifier(path) {\n      if (path.isReferencedIdentifier()) {\n        trackSelf(path);\n      }\n    },\n    Literal: function Literal(path) {\n      trackSelf(path);\n    },\n    ConditionalExpression: function ConditionalExpression(path) {\n      if (isIgnored(path.node)) {\n        return;\n      }\n\n      path.node.test = track(path.node.test, 'ConditionalExpression.test');\n      path.node.consequent = track(path.node.consequent, 'ConditionalExpression.consequent');\n      path.node.alternate = track(path.node.alternate, 'ConditionalExpression.alternate');\n      trackSelf(path);\n    },\n    NewExpression: function NewExpression(path) {\n      for (var i = 0, length = path.node.arguments.length; i < length; i++) {\n        path.node.arguments[i] = track(path.node.arguments[i], 'NewExpression.arguments');\n      }\n\n      trackSelf(path);\n    },\n    CallExpression: function CallExpression(path) {\n      // We have to check here that we aren't instrumenting the notifier function\n      if (!isInstrumentFunction(path.node)) {\n        for (var i = 0, length = path.node.arguments.length; i < length; i++) {\n          path.node.arguments[i] = track(path.node.arguments[i], 'CallExpression.arguments');\n        }\n      }\n\n      trackSelf(path);\n    },\n    MemberExpression: function MemberExpression(path) {\n      if (path.node.computed) {\n        path.node.property = track(path.node.property, 'MemberExpression.property');\n      }\n\n      path.node.object = track(path.node.object, 'MemberExpression.object');\n      trackSelf(path);\n    },\n    ReturnStatement: function ReturnStatement(path) {\n      trackArgument(path);\n    },\n    ObjectProperty: function ObjectProperty(path) {\n      // ignore string literal object literal keys\n      if (!path.node.computed) {\n        ignore(path.node.key);\n      }\n    },\n    ForStatement: function ForStatement(path) {\n      if (path.node.test != null) {\n        path.node.test = track(path.node.test, 'ForStatement.test');\n      }\n\n      if (path.node.update) {\n        path.node.update = track(path.node.update, 'ForStatement.update');\n      }\n    },\n    ForOfStatement: trackRightVisitor,\n    DoWhileStatement: trackTestVisitor,\n    WhileStatement: trackTestVisitor,\n    IfStatement: trackTestVisitor,\n    SwitchCase: function SwitchCase(path) {\n      if (path.node.test == null) {\n        return;\n      }\n\n      trackTest(path);\n    },\n    SwitchStatement: function SwitchStatement(path) {\n      path.node.discriminant = track(path.node.discriminant, 'SwitchStatement');\n    },\n    LogicalExpression: function LogicalExpression(path) {\n      path.node.left = trackLeft(path);\n      path.node.right = trackRight(path);\n      trackSelf(path);\n    },\n    BinaryExpression: function BinaryExpression(path) {\n      path.node.left = trackLeft(path);\n      path.node.right = trackRight(path);\n      trackSelf(path);\n    },\n    ClassExpression: trackSelfVisitor,\n    UnaryExpression: trackSelfVisitor,\n    UpdateExpression: function UpdateExpression(path) {\n      trackSelf(path);\n    },\n    ThisExpression: trackSelfVisitor,\n    FunctionExpression: trackSelfVisitor,\n    ArrowFunctionExpression: trackSelfVisitor,\n    ObjectExpression: trackSelfVisitor,\n    AwaitExpression: function AwaitExpression(path) {\n      trackArgument(path);\n      trackSelf(path);\n    },\n    AssignmentExpression: function AssignmentExpression(path) {\n      path.node.right = track(path.node.right, path.node.type);\n      ignore(path.node.left);\n      trackSelf(path);\n    },\n    ArrayExpression: function ArrayExpression(path) {\n      for (var i = 0; i < path.node.elements; i++) {\n        path.node.elements[i] = track(path.node.elements, 'ArrayExpression.elements');\n      }\n\n      trackSelf(path);\n    },\n    VariableDeclaration: function VariableDeclaration(path) {\n      var node = path.node;\n      var length = node.declarations.length;\n\n      for (var i = 0; i < length; i++) {\n        var declaration = node.declarations[i];\n        var init = declaration.init;\n\n        if (init != null) {\n          declaration.init = track(init, 'VariableDeclaration');\n        }\n      }\n    }\n  };\n  traverse(ast, visitors);\n  return {\n    insertions: insertions\n  };\n};\n\nexports.thorough = thorough;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/scuffka-javascript/dist/instrument.js\n// module id = GZXu\n// module chunks = 0 1","require('./_wks-define')('asyncIterator');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es7.symbol.async-iterator.js\n// module id = OYls\n// module chunks = 0 1","require('./_wks-define')('observable');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es7.symbol.observable.js\n// module id = QWe/\n// module chunks = 0 1","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n// module id = R6lU\n// module chunks = 0 1","\"use strict\";\n\nexports.__esModule = true;\nexports.VAR_INTERP = exports.VAR_MEMBER_PROPERTY_INTERP = exports.VAR_MEMBER_OBJECT_INTERP = exports.VAR_INSPECT = void 0;\nvar VAR_INSPECT = '$$LE__';\nexports.VAR_INSPECT = VAR_INSPECT;\nvar VAR_MEMBER_OBJECT_INTERP = '$$MO__';\nexports.VAR_MEMBER_OBJECT_INTERP = VAR_MEMBER_OBJECT_INTERP;\nvar VAR_MEMBER_PROPERTY_INTERP = '$$MP__';\nexports.VAR_MEMBER_PROPERTY_INTERP = VAR_MEMBER_PROPERTY_INTERP;\nvar VAR_INTERP = '$$GI__';\nexports.VAR_INTERP = VAR_INTERP;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/scuffka-javascript/dist/constants.js\n// module id = TVoi\n// module chunks = 0 1","module.exports = require(\"core-js/library/fn/symbol\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@babel/runtime/core-js/symbol.js\n// module id = xah7\n// module chunks = 0 1"],"sourceRoot":""}